# ABOUTME: Recipes for managing git worktrees, GitHub repos, and template files.
# ABOUTME: Invoked via: uv run --from just-bin just <recipe>

# List available recipes
default:
  @{{ just_executable() }} --list

# Create a new git worktree for a branch
wt-add branch base='main':
  #!/bin/bash
  set -euo pipefail

  BRANCH="{{ branch }}"
  BASE="{{ base }}"

  # Fetch latest from all remotes (skip if no remotes configured)
  if git remote | grep -q .; then
    git fetch --all --quiet

    # Fast-forward the base branch so new branches start from the latest state
    if git show-ref --verify --quiet "refs/remotes/origin/$BASE"; then
      if [ -d "$BASE" ]; then
        if git -C "$BASE" merge --ff-only "origin/$BASE" 2>/dev/null; then
          echo "Updated $BASE to $(git -C "$BASE" rev-parse --short HEAD)"
        else
          echo "Warning: could not fast-forward $BASE (may have diverged from origin)." >&2
        fi
      fi
    fi
  fi

  if git show-ref --verify --quiet "refs/heads/$BRANCH"; then
    # Local branch exists, check it out
    git worktree add "$BRANCH" "$BRANCH"
    echo "Checked out existing branch '$BRANCH'"
  elif git show-ref --verify --quiet "refs/remotes/origin/$BRANCH"; then
    # Remote branch exists, track it
    git worktree add "$BRANCH" "$BRANCH"
    echo "Checked out '$BRANCH' (tracking origin/$BRANCH)"
  else
    # New branch, create from base
    git worktree add -b "$BRANCH" "$BRANCH" "$BASE"
    echo "Created new branch '$BRANCH' from '$BASE'"
  fi
  echo "  cd $BRANCH/"

# Remove a git worktree and its local branch (accepts branch name or folder path)
wt-rm target:
  #!/bin/bash
  set -euo pipefail

  BRANCH="$(basename "{{ target }}")"

  if [ "$BRANCH" = "main" ]; then
    echo "Error: refusing to remove the main worktree." >&2
    exit 1
  fi

  git worktree remove "$BRANCH"

  if ! git branch -d "$BRANCH" 2>/dev/null; then
    echo "Worktree removed but branch '$BRANCH' has unmerged changes."
    echo "  To delete it anyway: git branch -D $BRANCH"
  else
    echo "Removed worktree and branch '$BRANCH'"
  fi

# Remove a worktree and delete its local and remote branches (accepts branch name or folder path)
wt-destroy target:
  #!/bin/bash
  set -euo pipefail

  BRANCH="$(basename "{{ target }}")"

  if [ "$BRANCH" = "main" ]; then
    echo "Error: refusing to destroy the main worktree." >&2
    exit 1
  fi

  git worktree remove "$BRANCH"

  git branch -D "$BRANCH"

  if git remote | grep -q . && git ls-remote --exit-code --heads origin "$BRANCH" >/dev/null 2>&1; then
    git push origin --delete "$BRANCH"
    echo "Removed worktree, local branch, and remote branch '$BRANCH'"
  else
    echo "Removed worktree and local branch '$BRANCH' (no remote branch found)"
  fi

# List all active git worktrees
wt-ls:
  git worktree list

# Alias for wt-ls
[private]
wt-list:
  @{{ just_executable() }} wt-ls

# Alias for wt-rm
[private]
wt-remove target:
  @{{ just_executable() }} wt-rm {{ target }}

# Fetch all remotes and fast-forward the main branch
wt-update:
  #!/bin/bash
  set -euo pipefail

  if ! git remote | grep -q .; then
    echo "No remotes configured. Nothing to update." >&2
    exit 1
  fi

  git fetch --all --quiet

  # Fast-forward main inside its worktree
  if git -C main merge --ff-only origin/main 2>/dev/null; then
    echo "Updated main to $(git -C main rev-parse --short HEAD)"
  else
    echo "Could not fast-forward main (diverged or worktree missing)." >&2
    echo "  Resolve manually: cd main && git pull"
    exit 1
  fi

# Clone an existing GitHub repo as a bare repo with a main worktree
repo-clone repo:
  #!/bin/bash
  set -euo pipefail

  if [ -d .git ] || [ -f .git ]; then
    echo "Error: .git already exists." >&2
    exit 1
  fi

  REPO="{{ repo }}"

  gh repo clone "$REPO" .git -- --bare
  git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
  git fetch origin --quiet
  git worktree add main main

  echo "Cloned $REPO with main worktree."
  echo "  cd main/"

# Initialize a new bare repo with a main worktree
repo-init:
  #!/bin/bash
  set -euo pipefail

  if [ -d .git ] || [ -f .git ]; then
    echo "Error: .git already exists." >&2
    exit 1
  fi

  git init --bare .git
  TREE=$(git hash-object -t tree /dev/null)
  COMMIT=$(echo "Initial commit" | git commit-tree "$TREE")
  git update-ref refs/heads/main "$COMMIT"
  git worktree add main main

  echo "Initialized bare repo with main worktree."
  echo "  cd main/"

# Create a GitHub repo and push main
repo-create repo visibility='private':
  #!/bin/bash
  set -euo pipefail

  REPO="{{ repo }}"
  VISIBILITY="{{ visibility }}"

  if git remote get-url origin &>/dev/null; then
    echo "Error: origin remote already exists ($(git remote get-url origin))." >&2
    exit 1
  fi

  gh repo create "$REPO" --"$VISIBILITY"

  PROTOCOL=$(gh config get git_protocol 2>/dev/null || echo "https")
  if [ "$PROTOCOL" = "ssh" ]; then
    URL="git@github.com:${REPO}.git"
  else
    URL="https://github.com/${REPO}.git"
  fi

  git remote add origin "$URL"
  git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
  git -C main push -u origin main

  echo ""
  echo "Created $VISIBILITY repo and pushed main."
  echo "  https://github.com/$REPO"

# Change GitHub repo visibility to public
repo-public:
  @{{ just_executable() }} _repo-visibility public

# Change GitHub repo visibility to private
repo-private:
  @{{ just_executable() }} _repo-visibility private

[private]
_repo-visibility visibility:
  #!/bin/bash
  set -euo pipefail

  VISIBILITY="{{ visibility }}"

  REMOTE_URL=$(git remote get-url origin 2>/dev/null) || {
    echo "Error: no origin remote configured." >&2
    exit 1
  }

  REPO=$(echo "$REMOTE_URL" | sed -E 's|.*github\.com[:/]||; s|\.git$||')
  if [ -z "$REPO" ]; then
    echo "Error: could not parse GitHub repo from $REMOTE_URL" >&2
    exit 1
  fi

  gh repo view "$REPO" >/dev/null 2>&1 || {
    echo "Error: GitHub repo $REPO not found." >&2
    exit 1
  }

  gh repo edit "$REPO" --visibility "$VISIBILITY"
  echo "$REPO is now $VISIBILITY."

# Update template files via copier (works around bare repo limitation)
template-update *args:
  #!/bin/bash
  set -euo pipefail

  if ! command -v uvx &>/dev/null; then
    echo "Error: uvx is required but not found. Install uv first." >&2
    exit 1
  fi

  if [ ! -f .copier-answers.yml ]; then
    echo "Error: .copier-answers.yml not found. Is this a copier-managed project?" >&2
    exit 1
  fi

  # Collect directories to exclude from copy (worktrees and config)
  EXCLUDE_ARGS=(--exclude .git --exclude .claude/)

  while IFS= read -r wt_path; do
    [ -z "$wt_path" ] && continue
    # Convert absolute worktree path to a name relative to project root
    wt_name="${wt_path##*/}"
    EXCLUDE_ARGS+=(--exclude "$wt_name/")
  done < <(git worktree list --porcelain | awk '/^worktree /{print $2}')

  # Resolve symlinks (macOS /var -> /private/var) so copier path comparisons work
  TMPDIR=$(realpath "$(mktemp -d)")
  trap 'rm -rf "$TMPDIR"' EXIT

  # Snapshot template-managed files before update
  rsync -a "${EXCLUDE_ARGS[@]}" ./ "$TMPDIR/"

  # Record files present before copier runs
  BEFORE=$(mktemp)
  (cd "$TMPDIR" && find . -not -path './.git/*' -not -name '.git' -type f | sort) > "$BEFORE"

  # Give copier a git repo to work with
  git -C "$TMPDIR" init --quiet
  git -C "$TMPDIR" add -A
  git -C "$TMPDIR" commit --quiet -m "pre-update snapshot"

  # Run copier update, passing through any extra args
  if ! uvx copier update --trust {{ args }} "$TMPDIR"; then
    echo "Error: copier update failed." >&2
    exit 1
  fi

  # Record files present after copier runs
  AFTER=$(mktemp)
  (cd "$TMPDIR" && find . -not -path './.git/*' -not -name '.git' -type f | sort) > "$AFTER"

  # Sync updated files back (exclude the temp git repo)
  rsync -a --exclude .git "$TMPDIR/" ./

  # Remove files that copier deleted (present before but not after)
  while IFS= read -r deleted; do
    target="./$deleted"
    if [ -f "$target" ]; then
      rm "$target"
      echo "Removed: $deleted"
    fi
  done < <(comm -23 "$BEFORE" "$AFTER")

  rm -f "$BEFORE" "$AFTER"

  echo "Template update complete."
